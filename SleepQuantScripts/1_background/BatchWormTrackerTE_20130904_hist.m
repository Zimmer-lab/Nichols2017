function BatchWormTrackerTE_20130904_hist(~,~,~,ticks,xmax,~,~,PlotFrameRate,MinWormArea,MaxWormArea) % Tracks all avi files in current working folder, analyzes the track files % and then and plots the data %Tracking prefs MinTrackLength = 20;  % changed from 20 20121902 % Min Length of valid track (in frames)%PlotFrameRate = 100;    % Display tracking r% Define Parameters & Intiallize variables   % ----------------------------------------% MinWormArea =60;    % Min area for object to be a valid worm% MinWormArea = 80;  %changed from 20 20121902 % %45 25original value - works for 1024x1024 jesse reset 10.14.05 from 15% MaxWormArea = 300;    % Max area for object to be a valid worm% MaxWormArea = 140; %260; %170 original value - works for 1024x1024 jesse reset 10.14.05 from 140MinDistance = 20;  % changed from 20 20121902 %    % Min Distance for connecting a new worm to an existing track (in pixels)% MinDistance = 10;esults every 'PlotFrameRate' framesSizeChangeThreshold = 25;    % Max size change between frames (in pixels)Tracks = [];% RingLimit = 30; %distance (in pixels) from the ring that you want to exclude from tracking%Data processing prefs% Plotting prefsgrey=[0.5 0.5 0.5];spdxmax=xmax;tickmarks=0:ticks:xmax; %tickmarks for subplotsOxmax=xmax;%worm tracker:% Get AVI movie for analysis% --------------------------%% [FileName, PathName] = uigetfile('*.avi', 'Select AVI Movie For Analysis');% if FileName == 0%     errordlg('No movie was selected for analysis');%     return;% endflnms=dir('*.avi'); %create structure from filenames[nummovs, dm] = size(flnms);cnt=0;for currentmov = 1:nummovs;        MovieName =(flnms(currentmov).name);    FileInfo = VideoReader(MovieName);      disp(strcat('... calculating wormsizes for movie', 32 , MovieName));    %MovieName = [PathName, FileName];%MovieName =(flnms(1).name);%64 FileInfo = aviinfo(MovieName);WTFigH = findobj('Tag', 'WTFIG');if isempty(WTFigH)    WTFigH = figure('Name', 'Worm Tracker', ...	    'NumberTitle', 'off', ...	    'Tag', 'WTFIG');else    figure(WTFigH);end% Analyze Movie% -------------% [FileName, PathName] = uigetfile('*.bmp', 'Select Background Image');% if FileName ~= 0%     background = imread([PathName, FileName],'bmp');% else %FileName == 0%     %create background image by averaging all frames% -- background is now function parameter% background = getbackgroundMZ64(MovieName,0);background = imread('background.tiff');fprintf('Background image loaded \n');% endimshow(background);Level = 0.3; %%%Level = 0.1;BW = ~im2bw(background, Level);[L,NUM] = bwlabel(BW);RINGSTATS = regionprops(L, {'Area'});idx = find([RINGSTATS.Area] > 1000);% & [RINGSTATS.Area] < 80000); %the ring area is within this range, may select other dark spotsBW2 = ismember(L,idx); %select objects that fit size criteria% [RingY, RingX] = find(BW2); [B,L,N] = bwboundaries(BW2); %obtain boundary coordinates for selected objects and put into cell Bimshow(BW2); hold on;for k=1:length(B),    boundary = B{k};    if(k <= N)        plot(boundary(:,2), boundary(:,1), 'g','LineWidth',2);    else        plot(boundary(:,2), boundary(:,1), 'r','LineWidth',2);    endendRingX = [];RingY = [];% LeftEdgeX = ones([1024 1]);% TopEdgeX = [];% RightEdgeX = 1024*ones([1024 1]);% BottomEdgeX = [];% LeftEdgeY = [];% TopEdgeY = ones([1024 1]);% RightEdgeY = [];% BottomEdgeY = 1024*ones([1024 1]);% for i = 1:1024%     TopEdgeX = [TopEdgeX; i];%     BottomEdgeX = [BottomEdgeX; i];%     LeftEdgeY = [LeftEdgeY; i];%     RightEdgeY = [RightEdgeY; i];% end% EdgeX = [LeftEdgeX;TopEdgeX;RightEdgeX;BottomEdgeX];% EdgeY = [LeftEdgeY;TopEdgeY;RightEdgeY;BottomEdgeY];%  EdgeX = [LeftEdgeX;TopEdgeX];%     EdgeY = [LeftEdgeY;TopEdgeY];%    for k=1:length(B)        boundary = B{k};        boundarysize = size(boundary);        if boundarysize(1) > 1000            NewRingX = boundary(:,2);            NewRingY = boundary(:,1);            RingX = [RingX;NewRingX]; %make an array of all the x coordinates of boundaries for all selected objects            RingY = [RingY;NewRingY];        end%          if (boundarysize(1) > 1000 & k > N)%             NewRingX = boundary(:,2);%             NewRingY = boundary(:,1);%             RingX = [RingX;NewRingX]; %make an array of all the x coordinates of boundaries for all selected objects%             RingY = [RingY;NewRingY];%         end%                 end% [RedundantEdgeX, ia, ib] = intersect([RingX, RingY], [EdgeX,EdgeY], 'rows');% if ib%     EdgeX(ib) = [];%     EdgeY(ib) = [];% end% RingX = [RingX;EdgeX];% RingY = [RingY;EdgeY];ComparisonArrayX = ones([length(RingX) 1]);ComparisonArrayY = ones([length(RingY) 1]); %for Frame = 1500:2000 for Frame = 1:FileInfo.NumberOfFrames     if Frame < 51         [MovieName ':']          Frame        % Get Frame        Mov.cdata = read(FileInfo, Frame);        %subtract the background from the frame        %the image becomes inverted with this operation        Movsubtract = imsubtract(background, Mov.cdata);         %put back ring in subtracted movie    %     imshow (BW2);         %imshow(Movsubtract);        % Convert frame to a binary image using auto thresholding        % Level = min(graythresh(Mov.cdata) - 0.15, 0.9);    %     Level = min(graythresh(Movsubtract), 0.9);    Level = 0.1; % changed from 0.15 (20120918)    % Level = 0.018; %value that worked for 1024x1024     %if Frame > 1570      %   Level = 0.07;    % else     %    Level = 0.09;     %end    %     BW = ~im2bw(Mov.cdata, Level);        BW = im2bw(Movsubtract, Level);        % Identify all objects        [L,NUM] = bwlabel(BW);        STATS = regionprops(L, {'Area', 'Centroid', 'FilledArea', 'Eccentricity', 'ConvexHull', 'MajorAxisLength'});        % Identify all worms by size, get their centroid coordinates    %     if ~mod(Frame,4)    %         WormIndices = find([STATS.Area] > MinWormArea & [STATS.Area] < MaxWormArea & [STATS.RingD] > RingLimit);    %     else            WormIndices = find([STATS.Area] > MinWormArea & [STATS.Area] < MaxWormArea);    %     end    %     WormIndices = find(min(RingDistance) > 20);        NumWorms = length(WormIndices);        WormCentroids = [STATS(WormIndices).Centroid];        WormCoordinates = [WormCentroids(1:2:2*NumWorms)', WormCentroids(2:2:2*NumWorms)'];        WormSizes = [STATS(WormIndices).Area];        WormFilledAreas = [STATS(WormIndices).FilledArea];        WormEccentricities = [STATS(WormIndices).Eccentricity];        WormRadLens = [];        for i = 1:NumWorms            Index = WormIndices(i);            WormConvexHull = STATS(Index).ConvexHull;            WormXConvexHull = WormConvexHull(:,1);            WormYConvexHull = WormConvexHull(:,2);            WormVortexNum = length(WormConvexHull);            WormXCoordinate = WormCoordinates(i,1);            WormYCoordinate = WormCoordinates(i,2);            UnitA = ones([WormVortexNum, 1]);            WormXCoordinateArray = WormXCoordinate * UnitA;            WormYCoordinateArray = WormYCoordinate * UnitA;            WormXD = (WormXConvexHull-WormXCoordinateArray).^2;            WormYD = (WormYConvexHull-WormYCoordinateArray).^2;            WormRadLens(i) = (sum(sqrt(WormXD+WormYD)))/WormVortexNum;        end        WormMajorAxes = [STATS(WormIndices).MajorAxisLength];    %     if length(WormMajorAxes) ~= length(WormRadLens)    %         pause;    %     end        WormRoundness = ((WormMajorAxes-WormRadLens)./WormRadLens);        if ~mod(Frame,4)            %determine the minimum distance between each object and the ring            %boundary            for i = 1:length(WormIndices)                XCentroid = [STATS(WormIndices(i)).Centroid(:,1)] * ComparisonArrayX;                YCentroid = [STATS(WormIndices(i)).Centroid(:,2)] * ComparisonArrayY;                % for j = 1:100000                RingDX = int16(round(RingX - XCentroid));                RingDY = int16(round(RingY - YCentroid));                D = sqrt(double(RingDX.^2+RingDY.^2));                RingDistance = min(D);                STATS(WormIndices(i)).RingD = RingDistance;            end            WormRingDistances = [STATS(WormIndices).RingD];        else            WormRingDistances = 0;        end        % Track worms         % -----------         if ~isempty(Tracks)            ActiveTracks = find([Tracks.Active]);        else            ActiveTracks = [];        end        % Update active tracks with new coordinates        for i = 1:length(ActiveTracks)            DistanceX = WormCoordinates(:,1) - Tracks(ActiveTracks(i)).LastCoordinates(1);            DistanceY = WormCoordinates(:,2) - Tracks(ActiveTracks(i)).LastCoordinates(2);            Distance = sqrt(DistanceX.^2 + DistanceY.^2);            [MinVal, MinIndex] = min(Distance);            %%%% &            if (MinVal <= MinDistance) & (abs(WormSizes(MinIndex) - Tracks(ActiveTracks(i)).LastSize) < SizeChangeThreshold)                Tracks(ActiveTracks(i)).Path = [Tracks(ActiveTracks(i)).Path; WormCoordinates(MinIndex, :)];                Tracks(ActiveTracks(i)).LastCoordinates = WormCoordinates(MinIndex, :);                Tracks(ActiveTracks(i)).Frames = [Tracks(ActiveTracks(i)).Frames, Frame];                Tracks(ActiveTracks(i)).Size = [Tracks(ActiveTracks(i)).Size, WormSizes(MinIndex)];                Tracks(ActiveTracks(i)).LastSize = WormSizes(MinIndex);                Tracks(ActiveTracks(i)).FilledArea = [Tracks(ActiveTracks(i)).FilledArea, WormFilledAreas(MinIndex)];                Tracks(ActiveTracks(i)).Eccentricity = [Tracks(ActiveTracks(i)).Eccentricity, WormEccentricities(MinIndex)];                Tracks(ActiveTracks(i)).MajorAxes = [Tracks(ActiveTracks(i)).MajorAxes, WormMajorAxes(MinIndex)];    %             Tracks(ActiveTracks(i)).RadLen = [Tracks(ActiveTracks(i)).RadLen, WormRadLens(MinIndex)];                Tracks(ActiveTracks(i)).Round = [Tracks(ActiveTracks(i)).Round, WormRoundness(MinIndex)];                Tracks(ActiveTracks(i)).RingEffect = [Tracks(ActiveTracks(i)).RingEffect, 0];                if ~mod(Frame,4)                    Tracks(ActiveTracks(i)).RingDistance = [Tracks(ActiveTracks(i)).RingDistance, WormRingDistances(MinIndex)];                    WormRingDistances(MinIndex) = [];                else                    Tracks(ActiveTracks(i)).RingDistance = [Tracks(ActiveTracks(i)).RingDistance, 0];                end                  WormCoordinates(MinIndex,:) = [];                WormSizes(MinIndex) = [];                WormFilledAreas(MinIndex) = [];                WormEccentricities(MinIndex) = [];                WormMajorAxes(MinIndex) = [];    %             WormRadLens(MinIndex) = [];                WormRoundness(MinIndex) = [];            else                Tracks(ActiveTracks(i)).Active = 0;                if length(Tracks(ActiveTracks(i)).Frames) < MinTrackLength                    Tracks(ActiveTracks(i)) = [];                    ActiveTracks = ActiveTracks - 1;                end            end        end        % Start new tracks for coordinates not assigned to existing tracks        NumTracks = length(Tracks);        for i = 1:length(WormCoordinates(:,1))            Index = NumTracks + i;            Tracks(Index).Active = 1;            Tracks(Index).Path = WormCoordinates(i,:);            Tracks(Index).LastCoordinates = WormCoordinates(i,:);            Tracks(Index).Frames = Frame;            Tracks(Index).Size = WormSizes(i);            Tracks(Index).LastSize = WormSizes(i);            Tracks(Index).FilledArea = WormFilledAreas(i);            Tracks(Index).Eccentricity = WormEccentricities(i);            Tracks(Index).MajorAxes = WormMajorAxes(i);    %         Tracks(Index).RadLen = WormRadLens(i);            Tracks(Index).Round = WormRoundness(i);            Tracks(Index).RingEffect = 0;            if ~mod(Frame,4)                Tracks(Index).RingDistance = WormRingDistances(i);            else                Tracks(Index).RingDistance = 0;            end        end        % Display every PlotFrameRate'th frame        if ~mod(Frame, PlotFrameRate)            PlotFrameTE(WTFigH, Mov,Movsubtract,BW, Tracks); %changed 2012/01/20 from PlotFrame;            FigureName = ['Worm Tracker - Results for Frame ', num2str(Frame)];            set(WTFigH, 'Name', FigureName);            %% -- Preanalysis Size Plotting            wormsizes=[Tracks.Size];            figure;             hist(wormsizes,100);            title(sprintf('%s',MovieName),'Interpreter','none','FontSize',15);            print(gcf,'-dpdf','-r300', sprintf('%s_Sizes.pdf',MovieName));            print (gcf,'-dpng','-r300',sprintf('%s_Sizes.png',MovieName));            saveas(gcf, sprintf('%s_Sizes.fig',MovieName), 'fig');            disp(' Pictures done baby, comment out: Preanalysis Size Plotting');    %             % % %         RGB = label2rgb(L);    %           RGB = label2rgb(L, @jet, 'k');    %           figure(2)    %           imshow(RGB);    %           pause;        end;     end; end;    % END for Frame = 1:FileInfo.NumberOfFrames end;    end